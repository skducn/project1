# coding: utf-8
# *******************************************************************
# Author     : John
# Date       : 2020-06-30
# Description: id 函数
# *******************************************************************
# id(object)函数是返回对象object在其生命周期内位于内存中的地址，id函数的参数类型是一个对象
# id() 函数返回对象的唯一标识符，标识符是一个整数。

print("1，变量指向内存2".center(100, "-"))
c = 2
d = 2
print(id(c), id(d), id(2))  # 2770782516944 2770782516944 2770782516944
print(c==d)  # True
print(c is d)  # True
print(d is c)  # True
# 分析：
# python 在内存中申请并分配一个整型对象来存储2，然后让变量c,d指向这个对象2，也就是指向这段内存（这里有点和C语言中的指针类似）。
# 而id(2)和id(c)的结果一样，说明id函数在作用于变量时，其返回的是变量指向的对象的地址。因为变量也是对象，所以在这里可以将c,d看成是对象2的一个引用。


print("2，变量指向内存2".center(100, "-"))

x = 2   # 内存中分配一个整型对象存储2 ，x指向了2
print(id(2))  # 140724688950976
print(id(x))  # 140724688950976
x = 3   # 内存中分配一个整型对象存储3 ，x指向了3  ，注意这里x与上一次的x不是同一个x
print(id(3))  # 140724688951008
print(id(x))  # 140724688951008

L = [1, 2, 3]
M = L
print(id(L))  # 2158806319424
print(id(M))  # 2158806319424

print(id(L[0]))  # 140724688950944  // 内存中有于没有1，所以只能新分配一个1
print(id(1))  # 140724688950944
print(id(L[1]))  # 140724688950976  //注意，这个值与 id(2)相同 ，如果系统内存中已经分配了2，列表中元素如果与之相同则直接引用，而不重新分配。
print(id(L[2]))  # 140724688951008  //注意，这个值与 id(3)相同 ，如果系统内存中已经分配了2，列表中元素如果与之相同则直接引用，而不重新分配。
L[0] = 22   # 修改了L的一个元素，只是将L[0]重新指向了对象22，而L[0]本身的存储地址并没有发生改变(L[0]是一个指针)，所以id(L)的值没有改变
print(id(L))  # 2158806319424
print(L)  # [22, 2, 3]
print(M)  # [22, 2, 3]


print("3，多个列表指向同一块内存".center(100, "-"))
def modify1(m, K):
    m = 2
    K = [4, 5, 6]
    return

def modify2(m, K):
    m = 2
    K[0] = 0
    return

n = 100
L = [1, 2, 3]
modify1(n, L)
print(n)  # 100
print(L)  # [1, 2, 3]

modify2(n, L)
print(n)  # 100
print(L)  # [0, 2, 3]


# 从结果可以看出，执行modify1( )之后，n和L都没有发生任何改变；执行modify2( )后，n还是没有改变，L发生了改变。因为在Python中参数传递采用的是值传递方式，在执行函数modify1时，
# 先获取n和L的id( )值，然后为形参m和K分配空间，让m和K分别指向对象100和对象[1,2,3]。m=2这句让m重新指向对象2，而K=[4,5,6]这句让K重新指向对象[4,5,6]。这种改变并不会影响到实参n和L
# ，所以在执行modify1之后，n和L没有发生任何改变；在执行函数modify2时，同理，让m和K分别指向对象2和对象[1,2,3]，然而K[0]=0让K[0]重新指向了对象0（注意这里K和L指向的是同一段内存），
# 所以对K指向的内存数据进行的任何改变也会影响到L，因此在执行modify2后，L发生了改变。

print("4，".center(100, "-"))

list1 = [1,2]
print(id(list1))  # 2607086781312
list1[0] = 100
print(id(list1))  # 2607086781312
list1.append(5)
print(id(list1))  # 2607086781312
list1.remove(100)
list1.remove(2)
list1.remove(5)
print(list1)  # []
print(id(list1))  # 2607086781312
list2 = []
print(id(list2))  # 2639881257920
list2 = []
print(id(list2))  # 2457113146752
list3 = []
print(id(list3))  # 2393154139840



list1 = [1, 2, 3]
print(id(list1))  # 2500201824576
list2 = [4, 2, 6]
print(id(list2))  # 2500201824832
print(id(list1[1]))  # 140724688950976
print(id(list2[1]))  # 140724688950976

