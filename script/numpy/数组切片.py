# coding: utf-8
# *****************************************************************
# Author     : John
# Date       : 2024-1-29
# Description: 数组切片
# 跟列表最重要的区别在于，数组切片是原始数组的视图。这意味 着数据不会被复制，视图上的任何修改都会直接反映到源数组上:
# 这是由于numpy设计的目的是处理大数据，因此，numpy会尽可能地避免数据复制，以提高效率。
# *****************************************************************

import numpy as np

arr = np.arange(10)
print(arr)  # [0 1 2 3 4 5 6 7 8 9]

arr_slice = arr[5:8]
arr_slice[1] = 1000
print(arr)  # [   0    1    2    3    4    5 1000    7    8    9]

arr_slice[:] = 64
print(arr)  # [ 0  1  2  3  4 64 64 64  8  9]

# 警告: 如果你想要得到的是ndarray切片的一份副本而非视图，就 需要显式地进行复制操作，例如arr[5:8].copy()。
arr_slice = arr[5:8].copy()
arr_slice[1] = 1000
print(arr_slice)  # [  64 1000   64]
print(arr)  # [ 0  1  2  3  4 64 64 64  8  9]


# todo 切片
arr2d = np.arange(1, 10).reshape((3, 3))
print(arr2d)
# [[1 2 3]
#  [4 5 6]
#  [7 8 9]]

print(arr2d[:2])
# [[1 2 3]
#  [4 5 6]]

print(arr2d[:2, 1:])
# [[2 3]
#  [5 6]]

print(arr2d[:, :1])
# [[1]
#  [4]
#  [7]]

arr2d[:, :1] = 0
print(arr2d)
# [[0 2 3]
#  [0 5 6]
#  [0 8 9]]


# todo 布尔型索引

# 实例：要选出对应于 名字"Bob"的所有行。
name = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
print(name.dtype)  # <U4
# 跟算术运算一样，数组的比较运算(如==)也是矢 量化的。因此，对name和字符串"Bob"的比较运算将会产生一个布尔 型数组:
print(name == 'Bob')  # [ True False False  True False False False]

# 生成一些正态分布的随机数据:
# 布尔型数组的长度必须跟被索引的轴长度一致。这里的7对应name元素个数
data = np.random.randn(7, 4)
print(data)
# [[ 1.16856911 -1.65389429  1.38749634 -0.50509082]
#  [-0.99654602 -0.87268025  1.08000806 -1.93433556]
#  [ 0.07342678 -0.55676919 -0.37699951 -0.01641898]
#  [ 0.13176835 -0.98106107 -0.5504412  -2.42750828]
#  [-0.65164842 -0.62176766  0.11270731  0.84426272]
#  [ 0.07706905  0.23756789 -0.92233733 -0.47705279]
#  [-0.10824698 -0.25769846 -3.15819917  1.32936211]]

# 假设每个名字都对应data数组中的一行，而我们想要选出对应于 名字"Bob"的所有行
# 通过布尔型数组，我们就可以轻松地选择出所有名字是"Bob"的行了。
print(data[name == 'Bob'])
# [[ 1.16856911 -1.65389429  1.38749634 -0.50509082]
#  [ 0.13176835 -0.98106107 -0.5504412  -2.42750828]]

print(data[name == 'Bob', 2:])
# [[ 1.38749634 -0.50509082]
#  [-0.5504412  -2.42750828]]

# 通过一维布尔数组设置整行或列的值
data[name != 'Bob'] = 7
print(data)
# [[ 1.16856911 -1.65389429  1.38749634 -0.50509082]
#  [ 7.          7.          7.          7.        ]
#  [ 7.          7.          7.          7.        ]
#  [ 0.13176835 -0.98106107 -0.5504412  -2.42750828]
#  [ 7.          7.          7.          7.        ]
#  [ 7.          7.          7.          7.        ]
#  [ 7.          7.          7.          7.        ]]

data[data < 0] = 0
print(data)
# [[1.16856911 0.         1.38749634 0.        ]
#  [7.         7.         7.         7.        ]
#  [7.         7.         7.         7.        ]
#  [0.13176835 0.         0.         0.        ]
#  [7.         7.         7.         7.        ]
#  [7.         7.         7.         7.        ]
#  [7.         7.         7.         7.        ]]


# todo 花式索引：它指的是利用整 数数组进行索引

arr = np.empty((8, 4))
for i in range(8):
    arr[i] = i
print(arr)
# [[0. 0. 0. 0.]
#  [1. 1. 1. 1.]
#  [2. 2. 2. 2.]
#  [3. 3. 3. 3.]
#  [4. 4. 4. 4.]
#  [5. 5. 5. 5.]
#  [6. 6. 6. 6.]
#  [7. 7. 7. 7.]]

# 为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数 列表或ndarray即可
print(arr[[4, 3, 0, 6]])
# [[4. 4. 4. 4.]
#  [3. 3. 3. 3.]
#  [0. 0. 0. 0.]
#  [6. 6. 6. 6.]]

# 使用负数索引将会从末尾开始选取行,从倒数1开始:
print(arr[[-3, -5, -7]])
# [[5. 5. 5. 5.]
#  [3. 3. 3. 3.]
#  [1. 1. 1. 1.]]

# 一次传入多个索引数组会有一点特别。它返回的是一个一维数 组，其中的元素对应各个索引元组:
arr = np.arange(32).reshape((8, 4))
print(arr)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]
#  [12 13 14 15]
#  [16 17 18 19]
#  [20 21 22 23]
#  [24 25 26 27]
#  [28 29 30 31]]
print(arr[[1, 5, 7, 2]])
# [[ 4  5  6  7]
#  [20 21 22 23]
#  [28 29 30 31]
#  [ 8  9 10 11]]
print(arr[[1, 5, 7, 2], [0, 3, 1, 2]])  # [ 4 23 29 10]  //最终选出的是元素(1,0)、(5,3)、 (7,1)和(2,2)
print(arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]])
# [[ 4  7  5  6]
#  [20 23 21 22]
#  [28 31 29 30]
#  [ 8 11  9 10]]
# np.ix_函数，它可以将两个一维整数数组转 换为一个用于选取方形区域的索引器:
print(arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])])
# [[ 4  7  5  6]
#  [20 23 21 22]
#  [28 31 29 30]
#  [ 8 11  9 10]]

# 注意：花式索引跟切片不一样，它总是将数据复制到新数组中。

# todo 数组转置和轴对换
# 转置(transpose)是重塑的一种特殊形式，它返回的是源数据的视 图(不会进行任何复制操作)。数组不仅有transpose方法，还有一个特 殊的T属性:
arr = np.arange(15).reshape((3, 5))
print(arr)
# [[ 0  1  2  3  4]
#  [ 5  6  7  8  9]
#  [10 11 12 13 14]]
print(arr.T)
# [[ 0  5 10]
#  [ 1  6 11]
#  [ 2  7 12]
#  [ 3  8 13]
#  [ 4  9 14]]


arr = np.arange(16).reshape((2, 2, 4))
print(arr)
# [[[ 0  1  2  3]
#   [ 4  5  6  7]]
#
#  [[ 8  9 10 11]
#   [12 13 14 15]]]

print(arr.swapaxes(1, 2))
# [[[ 0  4]
#   [ 1  5]
#   [ 2  6]
#   [ 3  7]]
#
#  [[ 8 12]
#   [ 9 13]
#   [10 14]
#   [11 15]]]
# swapaxes也是返回源数据的视图(不会进行任何复制操作)。