# $ pytest test_baidu.py -v --headed  //有头模式
# $ pytest test_baidu.py -v   //默认，无头模式
# pytest test_baidu.py -v --headed --browser webkit  //使用safari打开
#  pytest test_baidu.py -v --headed --browser firefox  // 使用firefox打开
# pytest test_baidu.py -v --headed --browser chromium  //使用chromium打开

# 常用参数说明：
# --headed: 在 headed 模式下运行测试（默认：headless / 无头模式）
# --browser: 在指定的浏览器类型，可以多次指定以使用多个浏览器
# 可选值为：chromium、firefox 或 webkit（默认：chromium）
# --browser-channel: 要使用的浏览器频道
# --slowmo: 将 Playwright 操作减慢指定的毫秒数。有助于看清执行过程（默认：0）
# --device: 要模拟的设备
# 可选值为：注册设备
# --output: 测试生成的产物存储目录（默认：test-results）
# --tracing: 是否为每个测试记录 trace（追踪信息）
# 可选值为：on、off 或 retain-on-failure（默认：off）
# --video: 是否为每个测试记录视频
# 可选值为：on、off 或 retain-on-failure（默认：off）
# --screenshot: 是否在每次测试后自动捕获截图
# 可选值为：on、off 或 only-on-failure（默认：off）
# --full-page-screenshot: 是否在失败时截取整个页面。默认仅捕获视口
# 需要同时启用 --screenshot 参数（默认：off）

# playwright codegen https://www.baidu.com

# 设置页面的视口大小，用于模拟不同的设备屏幕，如桌面、平板或手机。
# page.set_viewport_size({"width": 375, "height": 812}) # 模拟 iPhone X

# # 截取当前视口
# page.screenshot(path="screenshots/login.png")
# # 截取整个页面
# page.screenshot(path="screenshots/full_article.png", full_page=True)

# 在页面上下文中执行一段 JavaScript 表达式并返回其结果。
# 获取 localStorage 中的 item
# token = page.evaluate("() => localStorage.getItem('auth_token')")

# 等待 URL 变为特定的 dashboard 页面
# page.wait_for_url("**/dashboard")

# 等待页面 URL 变为指定的值或满足特定模式。常用于验证重定向或表单提交后的页面跳转。
# 等待 URL 变为特定的 dashboard 页面
# page.wait_for_url("**/dashboard")

# 等待页面达到特定的加载状态。参数同 goto 的 wait_until。
# 等待所有网络请求完成
# page.wait_for_load_state("networkidle")

# (不推荐用于常规测试) 强制暂停指定的毫秒数。仅应用于调试场景，在正式测试代码中应避免使用，因为它会引入不必要的延迟和不稳定性。
# 仅用于调试
# page.wait_for_timeout(5000) # 等待 5 秒

# 如果定位时，元素尚未出现或已消失，引发 NoSuchElementException 异常
# 如果定位后，元素处于未处于可交互状态，引发 ElementNotInteractableException 异常
# 如果定位后，元素正被其他元素遮挡，引发 ElementClickInterceptedException 异常
# 如果定位后，页面变化重新渲染，引发 StaleElementReferenceException 异常

# page.get_by_role() 通过无障碍访问角色进行定位。
# page.get_by_label() 通过关联标签的定位元素，通常是表单控件。
# page.get_by_text() 通过文本内容进行定位元素。
# page.get_by_placeholder() 通过placeholder属性定位元素，通常是输入框。
# page.get_by_alt_text() 通过 alt 属性定位元素，通常是图像。
# page.get_by_title() 通过 title 属性定位元素。
# page.get_by_test_id() 基于其 data-testid 属性定位元素（可配置属性名）。

# 参考链接：https://www.w3.org/TR/html-aria/#docconformance

# CSS Selector
# 描述：使用标准的 CSS 选择器语法进行定位。
# 语法示例：
# python
# 运行
# page.locator("css=selector")  # 显式声明
# page.locator("selector")       # 简写（默认使用 CSS 选择器）
# python
# 运行
# # 通过 ID 定位
# page.locator("#submit-button").click()
#
# # 通过 class 和属性定位
# page.locator("button.btn-primary[type='submit']").click()
# 何时使用：当元素没有唯一的、稳定的用户可见属性，但具有稳定的 ID、class 或其他属性时。
# XPath Selector
# 描述：使用 XPath 语法进行定位，功能比 CSS 更强大，例如可以基于文本查找父元素。
# 语法示例：
# python
# 运行
# page.locator("xpath=selector")
# python
# 运行
# # 定位包含特定文本的 span 元素的父级 div
# page.locator("xpath=//span[text()='产品 A']/../..").click()
# 何时使用：在需要复杂的 DOM 遍历（如查找兄弟节点、父节点）等 CSS 无法满足的场景下。


# 方法	描述
# .click()	单击元素。Playwright 会确保元素可点击后才执行。
# .fill()	清空输入框并填入文本。对于 input, textarea 等。
# .press()	模拟键盘按键。可用于输入文本或触发快捷键。
# .check()	勾选一个复选框 (checkbox) 或单选按钮 (radio button)。
# .uncheck()	取消勾选一个复选框。
# .select_option()	在 <select> 元素中选择一个或多个选项。
# .input_value()	获取输入框的当前值。
# .text_content()	获取元素的文本内容（不包括子元素）。
# .inner_text()	获取元素及其所有子元素的可见文本内容。
# .is_visible()	检查元素是否在视口中可见。
# .is_enabled()	检查元素（如按钮）是否为可用状态。

# todo 实例1
# from playwright.sync_api import sync_playwright
#
# input('1....')
# # 启动 playwright driver 进程
# p = sync_playwright().start()
#
# input('2....')
# # 启动浏览器, 返回 Browser 类型对象
# browser = p.chromium.launch(headless=False)
# # 加上 executable_path 参数
# browser = p.chromium.launch(headless=False,
#     executable_path='c:\\Program Files\\Google\\Chrome\\Application\\chrome.exe')
#
# # 创建新页面, 返回 Page 类型对象
# page = browser.new_page()
# page.goto("https://www.byhy.net/_files/stock1.html")
# print(page.title())  # 打印网页标题栏
#
# # 输入通讯，点击查询。这是定位与操作，是自动化重点，后文详细讲解
# page.locator('#kw').fill('通讯')  # 输入通讯
# page.locator('#go').click()      # 点击查询
#
# # 打印所有搜索内容
# lcs = page.locator(".result-item").all()
# for lc in lcs:
#     print(lc.inner_text())
#
# input('3....')
# # 关闭浏览器
# browser.close()
# input('4....')
# # 关闭 playwright driver 进程
# p.stop()


# todo with as 会话管理，让代码简化，不需要调用 start() 和 stop()：
# python
# 运行
# from playwright.sync_api import sync_playwright
#
# with sync_playwright() as p:
#     browser = p.chromium.launch(headless=False)
#     page = browser.new_page()
#     page.goto("https://www.byhy.net/_files/stock1.html")
#     print(page.title())
#     page.locator('#kw').fill('通讯\n')
#     page.locator('#go').click()
#
#     # 打印所有搜索内容
#     lcs = page.locator(".result-item").all()
#     for lc in lcs:
#         print(lc.inner_text())
#
#     browser.close()


# todo tracing 跟踪功能
# from playwright.sync_api import sync_playwright
#
# p = sync_playwright().start()
# browser = p.chromium.launch(headless=False)
#
# # 创建 BrowserContext对象
# context = browser.new_context()
# # 启动跟踪功能
# context.tracing.start(snapshots=True, sources=True, screenshots=True)
#
# page = context.new_page()
# page.goto("https://www.byhy.net/_files/stock1.html")
#
# # 搜索名称中包含 通讯 的股票
# page.locator('#kw').fill('通讯')
# page.locator('#go').click()
#
# page.wait_for_timeout(1000)  # 等待1秒
#
# lcs = page.locator(".result-item").all()
# for lc in lcs:
#     print(lc.inner_text())
#
# # 搜索名称中包含 软件 的股票
# page.locator('#kw').fill('软件')
# page.locator('#go').click()
# page.wait_for_timeout(1000)  # 等待1秒
#
# lcs = page.locator(".result-item").all()
# for lc in lcs:
#     print(lc.inner_text())
#
# # 结束跟踪
# context.tracing.stop(path="trace.zip")
#
# browser.close()
# p.stop()
# 执行完以后，我们发现，当前工作目录下面多了 trace.zip 这个跟踪数据文件。
# 怎么查看这个跟踪文件呢？有 2 种方法：
# 直接访问 trace.playwright.dev 这个网站，上传跟踪文件
# 执行命令 playwright show-trace trace.zip
# 具体查看内容，参考视频讲解。
# 这个功能对自动化测试特别有用。
# 测试结束后，对有疑问的测试用例的执行过程，可以详细的查看具体信息。

# todo 根据 tag 名、id、class 选择元素
# CSS Selector 可以根据 tag 名、id 属性 和 class 属性 来选择元素。
# 根据 tag 名选择元素的 CSS Selector 语法非常简单，直接写上 tag 名即可。
# 比如，要选择所有 tag 名为 div 的元素，就可以这样：
# python
# 运行
# locators = page.locator('div').all()
# 然后可以这样，打印所有 tag 名为 div 的元素的内部可见文本：
# python
# 运行
# for one in locators:
#     print(one.inner_text())
# 要获取所有 tag 名为 div 的元素的内部可见文本，也可以直接调用 all_inner_texts：
# python
# 运行
# texts = page.locator('div').all_inner_texts()
# 注意：如果 locator 调用匹配的结果是多个元素，调用针对单个元素的方法（比如 inner_text），会有错误抛出。

# todo 匹配多个元素
# 如果一个 locator 表达式匹配多个元素，要获取所有的元素对应的 locator 对象，使用 all 方法：
# python
# 运行
# locators = page.locator('.plant').all()
# 有时，我们只需要得到某种表达式对应的元素数量，可以使用 count 方法：
# python
# 运行
# count = page.locator('.plant').count()
# 返回结果就是匹配的元素数量，可以根据返回结果是否为 0 判断元素是否存在。
# 有时，我们只需要得到某种表达式对应的第一个，或者最后一个元素。
# 可以使用 first 和 last 属性：
# python
# 运行
# lct = page.locator('.plant')
# print(lct.first.inner_text(), lct.last.inner_text())
# 也可以通过 nth 方法，获取指定次序的元素，参数 0 表示第一个，1 表示第 2 个：
# python
# 运行
# lct = page.locator('.plant')
# print(lct.nth(1).inner_text())


# todo 元素内部定位
# 前面都是通过 Page 对象调用的 locator 方法，定位的范围是整个网页。
# 如果我们想在某个元素内部定位，可以通过 Locator 对象调用 locator 方法。
# 比如：
# python
# 运行
# lct = page.locator('#bottom')
#
# # 在 #bottom 对应元素的范围内 寻找标签名为 span 的元素
# eles = lct.locator('span').all()
# for e in eles:
#     print(e.inner_text())

# todo href
# # 根据属性选择元素
# element = page.locator('[href="http://www.miitbeian.gov.cn"]')
# # 打印出元素文本
# print(element.inner_text())
# 当然，前面可以加上标签名的限制，比如 a[href="http://www.miitbeian.gov.cn"] 表示选择所有标签名为 a，且属性 href 值为 http://www.miitbeian.gov.cn 的元素。
# 属性值用单引号、双引号都可以。
# 根据属性选择，还可以不指定属性值，比如 [href]，表示选择所有具有属性名为 href 的元素，不管它们的值是什么。
# CSS 还可以选择属性值包含某个字符串的元素：
# 比如，要选择 a 节点，里面的 href 属性包含了 miitbeian 字符串，就可以这样写：
# css
# a[href*="miitbeian"]
# 还可以选择属性值以某个字符串开头的元素：
# 比如，要选择 a 节点，里面的 href 属性以 http 开头，就可以这样写：
# css
# a[href^="http"]
# 还可以选择属性值以某个字符串结尾的元素：
# 比如，要选择 a 节点，里面的 href 属性以 gov.cn 结尾，就可以这样写：
# css
# a[href$="gov.cn"]

# todo get_by_text 文本包括
# # 根据文本内容选择所有元素
# elements = page.get_by_text('11').all()
#
# # 打印出元素文本
# for ele in elements:
#     print(ele.inner_text())
# 运行发现，打印结果为：
# plaintext
# 600111
# 600113
# 600115
# 如果你希望包含的内容是以 11 结尾的，就可以使用正则表达式对象作为参数，如下：
# python
# 运行
# import re
# elements = page.get_by_text(re.compile("11$")).all()
# 正则表达式 11$ 表示以 11 结尾，通过正则表达式，我们可以进行各种复杂的基于文本模式的定位。
# 关于详细的 Python 正则表达式的用法，点击这里学习。

# Playwright web自动化 - Python版
# https://www.bilibili.com/video/BV1Gw411N73T?spm_id_from=333.788.player.switch&vd_source=be21f48b876460dfe25064d745fdc372&p=17
